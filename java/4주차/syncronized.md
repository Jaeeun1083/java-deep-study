### 질문 리스트

> synchronized(암묵적인 락) 와 Reentrant Lock(명시적인 락)의 차이점

- synchronized와 달리 Reentrant Lock은 스레드 접근 제어를 설정할 수 있는 유연성을 가진다.

> synchronized를 쓰면 왜 느려지는지

- 초기 Java 5에서는 명시적 락이 훨씬 나은 경쟁 성능을 보여주지만, Java 6 버전에 들어오면서 명시적 락과의 성능 차이는 나지 않는다.
- synchronized는 블로킹하기 때문에 느려질 수 밖에 없다.

> 언제 암묵적인락을 쓰고 언제 명시적인 락을 사용할건지

- 암묵적 락만으로 해결할 수 없는 복잡한 상황에서는 명시적 락을 사용하고 그 왜에는 암묵적 락을 사용하는 것이 좋다.
- 암묵적 락은 표현 방법이 간단해 가독성이 좋지만, 명시적락은 락과 해제를 명시적으로 해줘야 하기 떄문에 암묵적 락보다 신경을 많이 써야 한다.

### 관련 내용 정리

#### 스레드와 원자성

> 스레드 원자성은 무엇인지

- 모든 스레드의 연산을 반영하는 것을 의미한다.

> 스레드 원자성 이슈는 무엇인지

- 프로그래밍 언어를 컴파일 해 기계어로 번역하면 여러 줄의 명령어가 나와 명령어의 원자성이 없어지게된다.

> 원자성을 이슈를 해결하는 방법은?

- 동기화를 통해 스레드의 원자성을 획득한다.
- 자바에서는 대표적으로 syncronized 메서드가 존재한다,

> 동기화

- 한 번에 하나의 스레드만 접근할 수 있도록 설정하는 것을 의미한다.

#### Lock

> 자바에서 락은 무엇인가

- 여러 스레드로 공유 리소스에 대한 접근을 제어하는 도구를 말한다.

> Lock 인터페이스 구조

```java
public interface Lock {  
	void lock();  
	
	void lockInterruptibly() throws InterruptedException; 
	 
	boolean tryLock();  
	
	boolean tryLock(long time, TimeUnit unit) throws InterruptedException;  
	
	void unlock();  
	
	Condition newCondition();  
}
```


#### 명시적 락과 암묵적 락

> 암묵적 락이란

- 동기화 방법을 사용해 락을 획득하는 것을 의미한다.
- 암묵적으로 락을 제공하지만, 잠금 획득 및 해제가 블록 구조 방식으로 강제된다.

> 명시적 락이란

- 락 인터페이스를 직접 구현하는 방식이며 조건 없는 락, 풀링 락, 타임아웃이 있는 락, 락 확보 대기 상태에 인터럽트를 걸 수 있다.

> 암묵적 락이랑 명시적 락의 차이

- 암묵적 락을 통해 쉽게 프로그래밍할 수 있고, 프로그래밍 오류를 방지할 수 있지만 락을 유연하게 사용해야 하는 경우 명시적 락을 사용한다.
- 명시적 락의 경우 잠금이 자동으로 해제하지 않기 때문에 꼭 잠금 해제해야 하는 책임이 따른다.

#### 명시적 락에서 공정성과 불공정성

> 명시적 락에서 공정성이란

- 공정성이란 순서를 지키며 락을 확보한다.
- 공정한 방법은 락을 확보하고자하는 스레드는 대기열에서 대기한다.

> 불공정 락이란

- 불공정 락은 순서 뛰어넘기가 일어난다.
- 불공정한 방법은 락을 확보하려는 시점에 락이 사용중이면 대기열에서 대기하고, 확보하려는 찰나 락이 해제된다면 락을 우선확보하게 된다.

> 공정과 불공정 방법의 차이는

- 공정하게 처리하면서 스레드를 반드시 멈추고 다시 실행시키는 동작이 성능에 큰 영향을 주기 때문이다.

#### ReentrantLock

> ReentrantLock이란

- ReentrantLock은 암묵적인 락만으로 해결할 수 없는 복잡한 상황에서 해결하기 위한 방법이다.

> ReentrantLock 기능

- 타임아웃을 지정해야 할 경우
- 풀링해서 확보해야 할 경우
- 대기 상태 스레드를 인터럽트 걸어야 할 경우
- 공정하게 처리해야 하는 경우
- 코드가 단일 블록 형태를 넘어서는 경우