## float과 double 형의 정밀도 문제
### 예상 질문 목록

#### float과 double 연산이 정밀도에 문제가 있는데 왜일까?

> 자바에서 float형과 double형은 부동 소수점 표기 방식으로 값이 저장되는데, 부동 소수점 표기 방식으로 표현할 수 있는 영역이 한정되어 있기 때문입니다.

#### 부동 소수점 연산으로 표현할 수 있는 크기는 얼마인가?

32 bit 크기로 한정할 때 정규화의 범위는 아래와 같이 표현이 가능합니다.

$$-1*2^{127}*M \sim\sf 1*2^{127}*M$$

이 때 M은 2와 가장 근접한 수입니다. 위 수치를 숫자로 표현한다면 아래와 같습니다.

$$1.4e-45f \sim\sf 3.4028235e+38f$$

#### 왜 저장할 수 있는 공간을 늘려 정밀도를 높이지 않는가?

> 한정된 메모리를 최대한 효율적이게 사용하기 위해 자료형 공간을 한정했습니다.

#### 정밀도를 높이는 방법은 무엇이 있는가?

> 유효부가 큰 double형을 사용해 연산하거나 라이브러리를 사용해 연산합니다.

> 기본 자료형의 한계를 소프트웨어적으로 보완해주는 라이브러리들로 필요한 곳에서 정확한 계산을 할 수 있습니다.

#### 오차가 없는 계산이 필요한 경우는 어떻게 하는가?

> 오차가 없는 계산이 필요할 땐 라이브러리를 사용하거나 소수점 자리수만큼 10을 곱해 정수로 만든 다음 계산하는 방법을 사용합니다.

### 참고 자료
#### 컴퓨터에서 소수점을 가진 수를 표현하는 방법
1. 고정 소수점(Fixed Point)
    1. 부호 비트와 정수와 소수 부분을 나눠 저장하는 방식이다.
    2. 4 바이트에서 저장한다면 부호비트 1비트와  정수부 15 비트, 소수부 16비트로 나눌 수 있다.
2. 부동 소수점(Float Point)
    1. 숫자를 지수표기로 표현한 다음, 값을 저장하는 방식이다.
    2. 부호 비트와 지수부와 가수부로 나눌 수 있다.
    3. 4 바이트에서 저장한다면 부호비트 1비트와 지수부 8비트, 가수부 23비트로 나눌 수 있다.

> 부동 소수점을 이용하면 고정 소수점보다 효율적으로 비트를 활용해서 다양한 숫자들을 표현할 수 있다.


```ad-note
대다수의 프로그래밍 언어는 IEEE 754 부동 소수점 표기 방식을 이용해 소수점을 표현하고, 연산한다.
```

### 자바에서는
- IEEE 754 국제 표준에 따라 부동 소수점 연산으로 소수를 가진 값을 표현한다.
- 부동 소수점 연산은 일반적인 반올림 규칙에 의해 유형 부동 소수점으로 반올림된다.
    - 반올림 규칙은 nearest even rounding이다.
        - 부동 소수점 뒤에 일부 자리수가 있는 짝수인 경우 해당 자리수를 제거하고, 홀수 인경우 다음 짝수로 설정된다.
            - 현재 값이 홀수인 경우 다음 짝수 값으로 올린다.
            - 현재 값이 짝수인 경우 현재 짝수 값으로 내린다.
  ```
  Round to nearest even rounding table
  // x0.01        x0.  
  // x0.10        x0.  
  // x0.11        x1. = x0. +1  
  // x1.00        x1.  
  // x1.01        x1.  
  // x1.10        x1. + 1  
  // x1.11        x1. + 1

  ```
- 부동 소수점을 한정된 공간에 표현하려 하는 상황
    - 지수 크기에 따라 오버플로우 및 언더플로우가 발생할 수 있다.
        - 값이 너무 크면 오버플로우가 발생할 수 있다.
        - 값이 0에 가까워는 특정 순간부터 언더플로우가 발생한다.
    - 유효부 크기에 따라 정밀도가 차이난다.
- 다운 캐스팅 할 때의 값과 문자열로 가져올 때의 값이 다르니 주의해야 한다.

```ad-question
Float.valueOf("1.00000017881393421514957253748434595763683319091796875001d").equals(1.00000017881393421514957253748434595763683319091796875001d)은 true일까?
```

```
In general, the two-step sequence of conversions, string to double followed by double to float, is not equivalent to converting a string directly to float. 

For example, if first converted to an intermediate double and then to float, the string "1.00000017881393421514957253748434595763683319091796875001d" results in the float value 1.0000002f; if the string is converted directly to float, 1.0000001f results.
```

#### 문제가 발생할 수 있는 상황
- valueOf를 이용해 선언할 때
- 연산할 때
- 다운 캐스팅할 때

#### **IEEE 754 표쥰** 찾아보자!
> 컴퓨터는 한정된 메모리 공간을 최대한 절약해서 연산해야 하기 때문에, 오차가 생긴다는 단점이 있지만, 기본적으로 부동소수점 자료형들로 실수들을 표현하고 있다.


### IEEE 754 부동 소수점 표현 방식
#### 부동 소수점 표기하는 방법
1. 십진수의 값을 이진 소수점으로 표현한다.
2. 이진 소수점을 각 영역에 맞게 대입한다.

$$(-1)^S * F * 2^E$$

S : 부호비트
E : 지수
F : 유효부(가수부)

- 32 비트에 저장하면 부호 비트를 1 비트로 표현하고, 지수를 8 비트로 표현하고, 유효부를 23비트로 표현한다.
- E는 Bias 표기 방식이며, 범위는 -127~+128이다. 이 중 -127은 비정규화를 표현하고, 128은 무한한 값을 표현한다.
- F은 유효부로 표현한다.

```ad-note
이진 소수점으로 표기하는 방식은 불필요하게 선행되는 0을 저장하지 않아 메모리를 효율적으로 사용하고 정밀도를 증가시킬 수 있다.
```

#### 소수 부분과 지수 사이에서 타협점
컴퓨터에서 데이터를 저장하기 위해서 고정된 크기를 사용하는데, 소수부분 크기와 지수 크기 사이 타협점을 찾아야 한다.

> 소수부분의 크기를 증가시키면 수의 정밀도가 높아지고, 지수의 크기를 증가시키면 수의 표현 범위가 늘어난다.

계산되는 지수가 너무 커서 지수 필드에 표현할 수 없을 때는 오버플로우가 발생하고, 음의 값을 갖는 지수의 절댓값이 너무 크면 지수 부분에 표현될 수 없을 경우 언더플로우가 발생한다.

> 언더플로우와 오버플로우의 발생을 줄이는 방법은 지수 부분을 크게 하는 2 배 정밀도 (double precision) 부동 소수점 연산이 있다. 기존 32 bit로 표현한 방식은 단일 정밀도 (single precision) 부동 소수점이라 한다.

#### Bias 표기 방식
부동 소수점이 들어간 데이터를 효율적으로 정렬할 수 있도록, 지수 파트를 Bias 표기 방식을 사용한다. 음수를 포함한 가장 최소 값을 `00...00` 으로 표현하고 최대값을 `11...11`로 표현한다.


#### 기본 공식
$$-1^{부호}*(1+소수)*2^{지수 - 바이어스}$$

Bias는 항상 고정 값을 가지며, $Bias = 2^{k-1}-1$이다.

> k = 8 이면 Bias는 127이다.

쉽게 말해서 $$2의 보수법 + 바이어스 상수 = 바이어스 표현법$$이라 생각하면 된다.


### 부동 소수점 형식
1. 정규화
    1. 정규화는 가장 자주 사용되는 유형이다.
    2. E(지수)가 -127 또는 128 값만 아니면 된다.
    3. F(유효부)는 1 + 소수로 표현한다.
2. 비정규화
    1. 비정규화는 정규화로 표현할 수 있는 수의 범위보다 작은 값을 표현하기 위해 만들었다.
    2. E(지수)가 -127이다.
    3. F(유효부)는 소수이다.
    4. 따라서 비정규화는 정규화에서 표현할 수 없는 0을 표현하거나 0에 매우 가까운 값을 표현하는 데 사용된다.
3. Infinity
    1. 자료형에 할당된 비트로는 표현할 수 없을 정도로 절대값이 큰 소수를 표현하는 요청은 Infinity라 한다.
    2. E(지수)는 128이다.
    3. F(유효부)는 0이다.
    4. 값을 표현할 수 없을만큼 큰 숫자들을 비교할 때 문제가 생기지 않도록 유효부를 전부 0으로 표현한다.
    5. 부호 비트를 통해 +∞, -∞를 표현할 수 있다.
4. NaN
    1. 수학적으로 정의하지 않는 값을 정의한다.
    2. E(지수)는 128이다.
    3. F(유효부)는 0이 아닌 값을 의미한다.
    4. 유효부의 값을 이용해 Infinity와 구별한다.
    5. 부호비트는 값에 영향을 주지 않는다.
    6. NaN에는 quite NaN과 signaling NaN으로 나뉜다.
        1.  quite NaN 은 F가 128인 경우이며 예외를 출력하지 않는다.
        2. signaling NaN은 F가 -126 이상 127 이하인 경우이며 예외를 출력한다.

### 부동 소수점 연산 방식
#### 부동 소수점 덧셈
1. 지수를 비교한다.
    1. 작은 쪽의 지수가 큰 쪽의 지수가 같아질 때까지 작은 수를 오른쪽으로 시프트한다.
2. 유효자리를 서로 더한다.
3. 정규화된 과학적 표기법으로 정돈한다.
    1. 오버플로우와 언더플로우를 검사한다.
4. 부호를 제외한 유효자리 길이에 맞게 반올림해준다.

#### 부동 소수점 곱셉
1. 두 수의 바이어스된 지수를 더한 값에 바이어스를 빼서 곱의 지수를 구한다.(바이어스 없이 지수를 더한다.)
2. 유효자리를 서로 곱한다.
3. 정규화된 형태로 정돈한다.
    1. 오버플로우와 언더 플로우를 검사한다.
4. 부호를 제외한 유효자리의 길이에 맞게 자리 맞춤을 해준다.
5. 부호가 같으면 결과의 부호는 양수이고 그렇지 않으면 음수이다.

참고 : [고정 소수점과 부동 소수점 강의](https://youtu.be/wI7mVv1GYwA)
참고 : [부동 소수점](http://keepcalmswag.blogspot.com/2018/08/1_42.html)
참고 : [Bias](https://stackoverflow.com/questions/2835278/what-is-a-bias-value-of-floating-point-numbers)
참고 : [부동소수점 : bias 표기](https://snoop-study.tistory.com/84)
