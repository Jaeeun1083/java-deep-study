
> 자바 애플리케이션 실행 동작을 설명해주세요

- 자바 파일은 컴파일러에 의해 바이트 코드로 변한됩니다. 
- 변환된 바이트 코드는 클래스 로더에 의해 값이 초기화 되고 메서드 영역에 적재됩니다. 
- 실행 엔진은 로딩된 데이터를 이용해 애플리케이션을 실행합니다.

> 클래스로더의 동작을 설명해주세요

- 클래스로더는 크게 검증, 연결, 초기화 작업으로 이루어져있습니다.

> 런타임 데이터 영역을 설명해주세요

- 런타임 데이터 영역은 스택, 네이티브 메서드 스택, PC 레지스터와 힙 영역, 메서드 영역이 있습니다.

> 실행 엔진 동작을 설명해주세요

- 실행 엔진은 메모리에 적재된 클래스 바이트 코드를 기계어로 변경해 명령어 단위로 실행합니다.
- 명령어 단위로 읽어서 수행하는 데 인터프리터 방식과 JIT 방식이 있습니다.

> 인터프리터가 무엇인지 설명해주세요

- 인터프리터는 실행 시점에 바이트 코드를 기계어로 변역을 수행합니다.

> JIT는 무엇인지 설명해주세요

- JIT 컴파일은 Just-In-Time의 약자로 동적 영역 프로그램을 실제 실행하는 시점에 기계어로 번역하는 컴파일 기법입니다.
- 실행 시점에 기계어 코드로 생성하면서 캐싱해 같은 함수가 계속 생성하는 것을 방지해 실행 속도를 높입니다.

> JIT에서 실행되는 기준은 무엇인지 설명해주세요

- 컴파일 임계치를 만족하는 코드는 JIT 컴파일러에 의해 컴파일이 수행됩니다.

> 컴파일 임계치란 무엇인지

- 코드 컴파일을 수행할 기준을 의미합니다. 컴파일 임계치는 JVM 내 메서드 호출 횟수와 메서드가 루프를 빠져나오기 전까지 회전한 횟수를 합친 것입니다.

> JIT의 단점은 무엇인지

- 실행이 시작되고 핫스팟을 식별할 때까지 인터프리터에 의해 실행된다는 점이고, 프로세스가 실장할 때마다 반복된다.

> AOT는 무엇인가요?

- 코드를 정적으로 컴파일 해 특정 공간에 네이티브 공간을 생성해 실행할 때, 바이트코드를 해석할 필요 없이 바로 실행되게 만들 수 있다.

> Java에서도 AOT가 가능한지

- Java에서 GraalVM을 사용해 런타임에 바이트 코드를 해설할 필요가 없고, 핫 스팟을 식별할 필요가 없으며 컴파일에 CPU 부하가 일어나지 않는다.

### 참고 자료
- https://junhyunny.github.io/information/java/jvm-execution-engine/
- https://foojay.io/today/java-performance-ahead-of-time-versus-just-in-time/
